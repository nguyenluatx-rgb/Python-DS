🧩 LỘ TRÌNH HỌC 1: ARRAY & LIST
🎯 Mục tiêu:
Hiểu cách hoạt động của mảng (array) và danh sách (list)
Biết cách thêm, xoá, duyệt, tìm kiếm, sắp xếp dữ liệu
Làm quen với độ phức tạp thời gian (time complexity)

🔹 1. Khái niệm cơ bản
🧠 Array (Mảng)
Là tập hợp các phần tử cùng kiểu dữ liệu, lưu liên tiếp nhau trong bộ nhớ.
Truy cập bằng chỉ số (index), bắt đầu từ 0.

Ví dụ trong Python:
numbers = [10, 20, 30, 40, 50]
print(numbers[0])  # 10

🔍 Đặc điểm:
Truy cập nhanh (O(1))
Thêm/xóa phần tử chậm (O(n)), vì phải dời các phần tử khác.


🧠 List (Danh sách động trong Python)
Python dùng list động, hoạt động giống array nhưng linh hoạt hơn — có thể thay đổi kích thước.
fruits = ["apple", "banana", "cherry"]
fruits.append("orange")   # thêm cuối
fruits.remove("banana")   # xoá phần tử
print(fruits)


| Thao tác    | Python ví dụ                      | Độ phức tạp     |
| ----------- | --------------------------------- | --------------- |
| Truy cập    | `arr[i]`                          | O(1)            |
| Thêm cuối   | `arr.append(x)`                   | O(1) trung bình |
| Thêm giữa   | `arr.insert(i, x)`                | O(n)            |
| Xóa phần tử | `arr.remove(x)` hoặc `del arr[i]` | O(n)            |
| Tìm kiếm    | `x in arr` hoặc vòng lặp          | O(n)            |
| Duyệt       | `for x in arr:`                   | O(n)            |

🔹 3. Bài tập luyện cơ bản
Tạo mảng gồm 10 số nguyên.
Tính tổng, giá trị lớn nhất, nhỏ nhất.
Thêm phần tử vào cuối, giữa, đầu danh sách.
Viết hàm kiểm tra xem một giá trị có nằm trong danh sách hay không.
Viết chương trình sắp xếp danh sách tăng dần.

🔹 4. Kiến thức thêm (nếu muốn hiểu sâu hơn)
Dynamic Array: cách Python mở rộng dung lượng list khi đầy.
Dynamic Array – Danh sách động
💡 Ý tưởng:
Một dynamic array (mảng động) là mảng có khả năng tự mở rộng khi đầy.
Nó bắt đầu với một kích thước cố định, nhưng khi bạn thêm phần tử vượt quá giới hạn, nó sẽ:
Tạo một mảng mới lớn hơn (thường gấp đôi kích thước)
Sao chép toàn bộ dữ liệu cũ sang mảng mới
Giải phóng bộ nhớ cũ
| Bước | Dung lượng | Số phần tử | Hành động             |
| ---- | ---------- | ---------- | --------------------- |
| 1    | 4          | 0          | Khởi tạo              |
| 2    | 4          | 1, 2, 3, 4 | Thêm đủ               |
| 3    | 8          | 5          | Mở rộng (double size) |
| 4    | 8          | 8          | Đầy lần nữa           |
| 5    | 16         | 9          | Mở rộng tiếp          |



Memory layout: cách các phần tử được lưu liên tiếp trong RAM.
🧠 Array:
Tất cả phần tử liên tiếp nhau trong RAM.
Mỗi phần tử có cùng kích thước.
Dễ truy cập vì chỉ cần biết “vị trí đầu” và “kích thước phần tử”.

🧠 Python list:
Thực ra không lưu trực tiếp giá trị mà lưu con trỏ (reference) đến các object.
Nên các phần tử không nhất thiết liên tiếp nhau trong RAM, chỉ là danh sách con trỏ trỏ đến nơi lưu
dữ liệu thật.


Amortized analysis: giải thích vì sao append() vẫn trung bình là O(1).
🧩 Vấn đề:
Lệnh append() bình thường rất nhanh (O(1)),
nhưng thỉnh thoảng rất chậm (O(n)) khi phải mở rộng mảng.

lst = []
for i in range(10000):
    lst.append(i)

9999 lần append đầu là O(1)
Một vài lần hiếm hoi (khi mở rộng) là O(n)
📊 Giải thích bằng “Amortized Analysis” (phân tích trung bình):
Ta tính chi phí trung bình trên toàn bộ chuỗi thao tác.
➡️ Dù đôi khi tốn O(n) (copy dữ liệu), nhưng vì mở rộng không diễn ra thường xuyên,
nên trung bình mỗi lần append chỉ mất O(1).